## Announcements

- Midterm grades out! A lot of partial credit. Avg ~80.

> I got 80 on the dot. Very average. Happy with the grade

# Inter-Domain Routing

## Overview

- Wrap up disc of lik state routing
  - what can go wrong
  - how to deal with it

- Intro to Distance Vector routing

## Recall: Flooding Example

- LSP generated by X at T=0
- Nodes become orange as they receive it

> TODO: revisit slides (copy diagram)

- Entire process repeats with LSPs for A, B, C
  - actually runs in parallel

## Making things disapeear
- need to remove failed/old links from toplogy
  - LSPs carry seq nums to distinguish new from old
  - Routers only accept (and forward) the "newest" LSP
  - Send a new LSP with cost infinity to signal a link down

- But also need to remove entire routers
  - Put a TTL (time to live) timer on each LSP
  - TTL in every LSP, decremented periodically (second) by each router
  - When TTL=0, purge the LSP and flood the network with an LSP with TTL 0 to tell everyone else to do the same

## When to Flood?

- Triggered by a topology change
  - Link or node failure/recovery or
  - Configuration change like updated link metric
  - Converges quickly, but can cause flood of updates
    > E.g. a bunch of routers lose power at the same time. Everyone else will flood the downed router to everyone else --> which everyone else will flood to everyone else. USES A TON OF BANDWIDTH AND CAN CRASH ROUTERS.

> Links go down maybe twice a month ish. Not super high prio.

- Periodically
  - Typically (say) every 30 minutes
  - Corrects for possible corruption of the data
  - Limits the rate of updates, but als failure recovery

## Route Convergence

- Getting consistent routing information to all nodes
  - E.g. all nodes having the same link-state database
  - Until routing protocol converges, strage things happen...

> Inconsistent states. Propogating updates. Routers can vary in efficiency of calculating shortest paths. very much NOT simultaneous. 
> - Can take a WHILE for network to converge. 
> - BUT it is consistent once it does
>
> Big Research Topic
> - IS converged?
> - how long it takes to converge?

- Consistent forwarding after convergence
  - All nodes have the same link-state datbase
  - All nodes forward packets on shortest pahts
  - the next router on ohe pat forwards to the next hop

> Can optimize for latency by:
> - reducing amount of link-state info sent
> - doing simpler computation of shortest-path
>
> Compromises exist but it's a tradeoff. Need to do an overall time cost to check for efficiency (convergence + delivery speeds).

## Link State Convergence Delay

- Sources of convergence delay
  - Detection latency
  - flooding of link-state information
  - Shortest-path computation
  - Creating the forwarding table

- Poor performance during convergence period
  - Lost packets due to black holes and TTL expiry
  - Looping packets consuming resources
  - Out-of-order packets reaching the destination

> Black Hole: Link is down but detection lags (wait for expiry, wait on propagation to all)

- Lack of convergence is very bad for
  - VoIP
  - online gaming
  - media streaming

> TTL is the biggest indicator of convergence issue. The lost packets could be due to routers getting overwhelmed - hard to tell the true root cause based off just lost packets.

> Reboot every router is a viable solution. Case example: misconfigured router as opposed to network algorithm being wrong. 

## Transient Disruptions
  
- Detection delay
  - Router does not detect a filaed link imeediately
  - ... and forwards data packets into a black hold
  - depends on timeout for detecting lost LSPs

> TODO: revisit slides (copy diagram)

> Squirels eat fiber optic cables. Sharks eat undersea cables (their brain detected electricity and they were attracted to related wires) - big issue in the 1800s 1900s.

- Inconsistent linkstate database
  - Some routers know about failure before others
  - the shortest paths are no longer onsistent
  - can cause transient forwarding loops

> TODO: revisit slides (copy diagram)

## Reducing Delay

- Faster detection
  - Smaller LSP timers
  - Link-layer tech that can detect failures

> Note that TTL for this network layer (time) is diff than the TTL for the IP layer (hops).

- Faster flooding
  - Flood immediately
  - Sending link-state packets with high-priority

> Segment networks into specific link-states can help optimize but only scales the fundamental problem to the segment-scale. Doesn't address the fundemental issue of flooding.

- Faster computation
  - Faster processors on routers
  - Incremental Dijkstra's algorithm
    - or specialized hardware (e.g. implement Dijkstra's in hardware)

- Faster forwarding-table update
  - Data structures supporting incremental updates

## Real Link-state protocols

- OSPF (Open Shoftest Path First) and IS-IS
  - MMost wiedely used intra-domain routing protocols
  - Run by almost all ISPs and many large organizations

- Basic link state algorithm plus many features:
  - authentication of routing messages
  - Extra hierarchy: Partition into routing areas
    - "Border" router pretends to be directly connected to all routers in an area (answers for them)
  - Load balancing: Multiple equal cost routes

> The farther and farther you abstract into higher levels of abstraction, the further you get from reality. At some point, you can't guarantee convergence -- you just accept the fact that some part of the router will always lose packets

## Link State evaluation

- Strengths
  - Loop-free as long as LS databases have converged
    - Can have transient routing loops - shouldn't last long
  - Messages are small
  - Converges quickly
  - guaranteed to converge

Weaknesses
  - Most flood data across entire network (scalability)
  - Must maintain state for entire topology (large database)

## **Distance Vector** algorithm

- Base assumpion
  - Each router knows its **own address** and the cost to reach each of its **directly connected neighbors**

- Bellman-Ford algorithm
  - Distributed route conputation using **only neighbor router info**
  - **No flooding like in link-state routing**
    - send less info and only when necessary
    - NOT foolproof but works most of the time
    - will fundamentally introduce the routing loop problem
        - not only detection delay like in link-state

> Distributed shortest path.

- Mitigating loops (cannot 100% solve)
  - Split horizon and poison reverse

## Bellman-Ford Algorithm

> Basic concept: You only tell neighbors about the routes that you've learned. Just what you know. No flooding(You don't forward the info you get from other people). You trust your neighbors

- Define distance at each node X
  - $d_x(y)$ = cost of least-cost path from X to Y
- Update distances based on neighbors
  - $d_x(y)$ = $min\{c(x,v) + d_v(y)\}$ over all neighbors V

> TODO: revisit slides (copy diagram)

- no more full paths
- "I can get you there with this cost" that's all
- You share vector of distances you can go to is all

## Distance Vector Algorithm

- Iterative, Asynchronous: each local iteraction caused by
  - Local link cost chagne
  - Distance vector update message from neighbor

- Distributed:
  - Each node notifies nethbors when its DV changes
  - Neighbors then notify their neighbors if necessary

> TODO: revisit slides (copy diagram)

Each Node
- **wait** for (change in local link cost or mrssage from neighbor)
- **recompute** estimates
- if distance to any destination has changed, **notify** neighbors

> Neighbor to Neighbor only --> scales so much better.
> core concept of global internet (aka inter-domain routing). 

Chronology
- Bellman Ford ==> Dijstras
- Distance Vector || Link-State
  - developed in parallel
    > as soon as you introduce flooding, you kind of think of "how am I going to optimize this to scale?"